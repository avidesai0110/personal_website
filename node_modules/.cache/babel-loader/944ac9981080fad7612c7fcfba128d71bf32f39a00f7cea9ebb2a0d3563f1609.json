{"ast":null,"code":"import { BufferAttribute, BufferGeometry, Float32BufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, MathUtils, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, Vector3 } from 'three';\nfunction computeTangents(geometry, MikkTSpace, negateSign = true) {\n  if (!MikkTSpace || !MikkTSpace.isReady) {\n    throw new Error('BufferGeometryUtils: Initialized MikkTSpace library required.');\n  }\n  function getAttributeArray(attribute) {\n    if (attribute.normalized || attribute.isInterleavedBufferAttribute) {\n      const srcArray = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;\n      const dstArray = new Float32Array(attribute.getCount() * attribute.itemSize);\n      for (let i = 0, j = 0; i < attribute.getCount(); i++) {\n        dstArray[j++] = MathUtils.denormalize(attribute.getX(i), srcArray);\n        dstArray[j++] = MathUtils.denormalize(attribute.getY(i), srcArray);\n        if (attribute.itemSize > 2) {\n          dstArray[j++] = MathUtils.denormalize(attribute.getZ(i), srcArray);\n        }\n      }\n      return dstArray;\n    }\n    if (attribute.array instanceof Float32Array) {\n      return attribute.array;\n    }\n    return new Float32Array(attribute.array);\n  }\n\n  // MikkTSpace algorithm requires non-indexed input.\n\n  const _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\n  // Compute vertex tangents.\n\n  const tangents = MikkTSpace.generateTangents(getAttributeArray(_geometry.attributes.position), getAttributeArray(_geometry.attributes.normal), getAttributeArray(_geometry.attributes.uv));\n\n  // Texture coordinate convention of glTF differs from the apparent\n  // default of the MikkTSpace library; .w component must be flipped.\n\n  if (negateSign) {\n    for (let i = 3; i < tangents.length; i += 4) {\n      tangents[i] *= -1;\n    }\n  }\n\n  //\n\n  _geometry.setAttribute('tangent', new BufferAttribute(tangents, 4));\n  if (geometry !== _geometry) {\n    geometry.copy(_geometry);\n  }\n  return geometry;\n}\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nfunction mergeBufferGeometries(geometries, useGroups = false) {\n  const isIndexed = geometries[0].index !== null;\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n  const attributes = {};\n  const morphAttributes = {};\n  const morphTargetsRelative = geometries[0].morphTargetsRelative;\n  const mergedGeometry = new BufferGeometry();\n  let offset = 0;\n  for (let i = 0; i < geometries.length; ++i) {\n    const geometry = geometries[i];\n    let attributesCount = 0;\n\n    // ensure that all geometries are indexed, or none\n\n    if (isIndexed !== (geometry.index !== null)) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.');\n      return null;\n    }\n\n    // gather attributes, exit early if they're different\n\n    for (const name in geometry.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n        return null;\n      }\n      if (attributes[name] === undefined) attributes[name] = [];\n      attributes[name].push(geometry.attributes[name]);\n      attributesCount++;\n    }\n\n    // ensure geometries have the same number of attributes\n\n    if (attributesCount !== attributesUsed.size) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.');\n      return null;\n    }\n\n    // gather morph attributes, exit early if they're different\n\n    if (morphTargetsRelative !== geometry.morphTargetsRelative) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.');\n      return null;\n    }\n    for (const name in geometry.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.');\n        return null;\n      }\n      if (morphAttributes[name] === undefined) morphAttributes[name] = [];\n      morphAttributes[name].push(geometry.morphAttributes[name]);\n    }\n\n    // gather .userData\n\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n    mergedGeometry.userData.mergedUserData.push(geometry.userData);\n    if (useGroups) {\n      let count;\n      if (isIndexed) {\n        count = geometry.index.count;\n      } else if (geometry.attributes.position !== undefined) {\n        count = geometry.attributes.position.count;\n      } else {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute');\n        return null;\n      }\n      mergedGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  }\n\n  // merge indices\n\n  if (isIndexed) {\n    let indexOffset = 0;\n    const mergedIndex = [];\n    for (let i = 0; i < geometries.length; ++i) {\n      const index = geometries[i].index;\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset);\n      }\n      indexOffset += geometries[i].attributes.position.count;\n    }\n    mergedGeometry.setIndex(mergedIndex);\n  }\n\n  // merge attributes\n\n  for (const name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name]);\n    if (!mergedAttribute) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.');\n      return null;\n    }\n    mergedGeometry.setAttribute(name, mergedAttribute);\n  }\n\n  // merge morph attributes\n\n  for (const name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length;\n    if (numMorphTargets === 0) break;\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n    mergedGeometry.morphAttributes[name] = [];\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = [];\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i]);\n      }\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n      if (!mergedMorphAttribute) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.');\n        return null;\n      }\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n    }\n  }\n  return mergedGeometry;\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nfunction mergeBufferAttributes(attributes) {\n  let TypedArray;\n  let itemSize;\n  let normalized;\n  let arrayLength = 0;\n  for (let i = 0; i < attributes.length; ++i) {\n    const attribute = attributes[i];\n    if (attribute.isInterleavedBufferAttribute) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.');\n      return null;\n    }\n    if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n    if (TypedArray !== attribute.array.constructor) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.');\n      return null;\n    }\n    if (itemSize === undefined) itemSize = attribute.itemSize;\n    if (itemSize !== attribute.itemSize) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.');\n      return null;\n    }\n    if (normalized === undefined) normalized = attribute.normalized;\n    if (normalized !== attribute.normalized) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.');\n      return null;\n    }\n    arrayLength += attribute.array.length;\n  }\n  const array = new TypedArray(arrayLength);\n  let offset = 0;\n  for (let i = 0; i < attributes.length; ++i) {\n    array.set(attributes[i].array, offset);\n    offset += attributes[i].array.length;\n  }\n  return new BufferAttribute(array, itemSize, normalized);\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nfunction interleaveAttributes(attributes) {\n  // Interleaves the provided attributes into an InterleavedBuffer and returns\n  // a set of InterleavedBufferAttributes for each attribute\n  let TypedArray;\n  let arrayLength = 0;\n  let stride = 0;\n\n  // calculate the the length and type of the interleavedBuffer\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i];\n    if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n    if (TypedArray !== attribute.array.constructor) {\n      console.error('AttributeBuffers of different types cannot be interleaved');\n      return null;\n    }\n    arrayLength += attribute.array.length;\n    stride += attribute.itemSize;\n  }\n\n  // Create the set of buffer attributes\n  const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);\n  let offset = 0;\n  const res = [];\n  const getters = ['getX', 'getY', 'getZ', 'getW'];\n  const setters = ['setX', 'setY', 'setZ', 'setW'];\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j];\n    const itemSize = attribute.itemSize;\n    const count = attribute.count;\n    const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n    res.push(iba);\n    offset += itemSize;\n\n    // Move the data for each attribute into the new interleavedBuffer\n    // at the appropriate offset\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        iba[setters[k]](c, attribute[getters[k]](c));\n      }\n    }\n  }\n  return res;\n}\n\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\nfunction estimateBytesUsed(geometry) {\n  // Return the estimated memory used by this geometry in bytes\n  // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n  // for InterleavedBufferAttributes.\n  let mem = 0;\n  for (const name in geometry.attributes) {\n    const attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n  const indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry>}\n */\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n  tolerance = Math.max(tolerance, Number.EPSILON);\n\n  // Generate an index buffer if the geometry doesn't have one, or optimize it\n  // if it's already available.\n  const hashToIndex = {};\n  const indices = geometry.getIndex();\n  const positions = geometry.getAttribute('position');\n  const vertexCount = indices ? indices.count : positions.count;\n\n  // next value for triangle indices\n  let nextIndex = 0;\n\n  // attributes and new attribute arrays\n  const attributeNames = Object.keys(geometry.attributes);\n  const attrArrays = {};\n  const morphAttrsArrays = {};\n  const newIndices = [];\n  const getters = ['getX', 'getY', 'getZ', 'getW'];\n\n  // initialize the arrays\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    attrArrays[name] = [];\n    const morphAttr = geometry.morphAttributes[name];\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill().map(() => []);\n    }\n  }\n\n  // convert the error tolerance to an amount of decimal places to truncate to\n  const decimalShift = Math.log10(1 / tolerance);\n  const shiftMultiplier = Math.pow(10, decimalShift);\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i;\n\n    // Generate a hash for the vertex attributes at the current index 'i'\n    let hash = '';\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j];\n      const attribute = geometry.getAttribute(name);\n      const itemSize = attribute.itemSize;\n      for (let k = 0; k < itemSize; k++) {\n        // double tilde truncates the decimal value\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n      }\n    }\n\n    // Add another reference to the vertex if it's already\n    // used by another index\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      // copy data to the new index in the attribute arrays\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j];\n        const attribute = geometry.getAttribute(name);\n        const morphAttr = geometry.morphAttributes[name];\n        const itemSize = attribute.itemSize;\n        const newarray = attrArrays[name];\n        const newMorphArrays = morphAttrsArrays[name];\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k];\n          newarray.push(attribute[getterFunc](index));\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n            }\n          }\n        }\n      }\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  }\n\n  // Generate typed arrays from new attribute arrays and update\n  // the attributeBuffers\n  const result = geometry.clone();\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    const oldAttribute = geometry.getAttribute(name);\n    const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n    const attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n    result.setAttribute(name, attribute);\n\n    // Update the attribute arrays\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j];\n        const buffer = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n        const morphAttribute = new BufferAttribute(buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n        result.morphAttributes[name][j] = morphAttribute;\n      }\n    }\n  }\n\n  // indices\n\n  result.setIndex(newIndices);\n  return result;\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry>}\n */\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === TrianglesDrawMode) {\n    console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.');\n    return geometry;\n  }\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n    let index = geometry.getIndex();\n\n    // generate index if not present\n\n    if (index === null) {\n      const indices = [];\n      const position = geometry.getAttribute('position');\n      if (position !== undefined) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\n        return geometry;\n      }\n    }\n\n    //\n\n    const numberOfTriangles = index.count - 2;\n    const newIndices = [];\n    if (drawMode === TriangleFanDrawMode) {\n      // gl.TRIANGLE_FAN\n\n      for (let i = 1; i <= numberOfTriangles; i++) {\n        newIndices.push(index.getX(0));\n        newIndices.push(index.getX(i));\n        newIndices.push(index.getX(i + 1));\n      }\n    } else {\n      // gl.TRIANGLE_STRIP\n\n      for (let i = 0; i < numberOfTriangles; i++) {\n        if (i % 2 === 0) {\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n          newIndices.push(index.getX(i + 2));\n        } else {\n          newIndices.push(index.getX(i + 2));\n          newIndices.push(index.getX(i + 1));\n          newIndices.push(index.getX(i));\n        }\n      }\n    }\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\n    }\n\n    // build final geometry\n\n    const newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode);\n    return geometry;\n  }\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes(object) {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error('THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.');\n    return null;\n  }\n  const _vA = new Vector3();\n  const _vB = new Vector3();\n  const _vC = new Vector3();\n  const _tempA = new Vector3();\n  const _tempB = new Vector3();\n  const _tempC = new Vector3();\n  const _morphA = new Vector3();\n  const _morphB = new Vector3();\n  const _morphC = new Vector3();\n  function _calculateMorphedAttributeData(object, material, attribute, morphAttribute, morphTargetsRelative, a, b, c, modifiedAttributeArray) {\n    _vA.fromBufferAttribute(attribute, a);\n    _vB.fromBufferAttribute(attribute, b);\n    _vC.fromBufferAttribute(attribute, c);\n    const morphInfluences = object.morphTargetInfluences;\n    if (material.morphTargets && morphAttribute && morphInfluences) {\n      _morphA.set(0, 0, 0);\n      _morphB.set(0, 0, 0);\n      _morphC.set(0, 0, 0);\n      for (let i = 0, il = morphAttribute.length; i < il; i++) {\n        const influence = morphInfluences[i];\n        const morph = morphAttribute[i];\n        if (influence === 0) continue;\n        _tempA.fromBufferAttribute(morph, a);\n        _tempB.fromBufferAttribute(morph, b);\n        _tempC.fromBufferAttribute(morph, c);\n        if (morphTargetsRelative) {\n          _morphA.addScaledVector(_tempA, influence);\n          _morphB.addScaledVector(_tempB, influence);\n          _morphC.addScaledVector(_tempC, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\n        }\n      }\n      _vA.add(_morphA);\n      _vB.add(_morphB);\n      _vC.add(_morphC);\n    }\n    if (object.isSkinnedMesh) {\n      object.boneTransform(a, _vA);\n      object.boneTransform(b, _vB);\n      object.boneTransform(c, _vC);\n    }\n    modifiedAttributeArray[a * 3 + 0] = _vA.x;\n    modifiedAttributeArray[a * 3 + 1] = _vA.y;\n    modifiedAttributeArray[a * 3 + 2] = _vA.z;\n    modifiedAttributeArray[b * 3 + 0] = _vB.x;\n    modifiedAttributeArray[b * 3 + 1] = _vB.y;\n    modifiedAttributeArray[b * 3 + 2] = _vB.z;\n    modifiedAttributeArray[c * 3 + 0] = _vC.x;\n    modifiedAttributeArray[c * 3 + 1] = _vC.y;\n    modifiedAttributeArray[c * 3 + 2] = _vC.z;\n  }\n  const geometry = object.geometry;\n  const material = object.material;\n  let a, b, c;\n  const index = geometry.index;\n  const positionAttribute = geometry.attributes.position;\n  const morphPosition = geometry.morphAttributes.position;\n  const morphTargetsRelative = geometry.morphTargetsRelative;\n  const normalAttribute = geometry.attributes.normal;\n  const morphNormal = geometry.morphAttributes.position;\n  const groups = geometry.groups;\n  const drawRange = geometry.drawRange;\n  let i, j, il, jl;\n  let group, groupMaterial;\n  let start, end;\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n  if (index !== null) {\n    // indexed buffer geometry\n\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j);\n          b = index.getX(j + 1);\n          c = index.getX(j + 2);\n          _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n          _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(index.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i);\n        b = index.getX(i + 1);\n        c = index.getX(i + 2);\n        _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n        _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n      }\n    }\n  } else {\n    // non-indexed buffer geometry\n\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j;\n          b = j + 1;\n          c = j + 2;\n          _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n          _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = i;\n        b = i + 1;\n        c = i + 2;\n        _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n        _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n      }\n    }\n  }\n  const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);\n  const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);\n  return {\n    positionAttribute: positionAttribute,\n    normalAttribute: normalAttribute,\n    morphedPositionAttribute: morphedPositionAttribute,\n    morphedNormalAttribute: morphedNormalAttribute\n  };\n}\nfunction mergeGroups(geometry) {\n  if (geometry.groups.length === 0) {\n    console.warn('THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.');\n    return geometry;\n  }\n  let groups = geometry.groups;\n\n  // sort groups by material index\n\n  groups = groups.sort((a, b) => {\n    if (a.materialIndex !== b.materialIndex) return a.materialIndex - b.materialIndex;\n    return a.start - b.start;\n  });\n\n  // create index for non-indexed geometries\n\n  if (geometry.getIndex() === null) {\n    const positionAttribute = geometry.getAttribute('position');\n    const indices = [];\n    for (let i = 0; i < positionAttribute.count; i += 3) {\n      indices.push(i, i + 1, i + 2);\n    }\n    geometry.setIndex(indices);\n  }\n\n  // sort index\n\n  const index = geometry.getIndex();\n  const newIndices = [];\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    const groupStart = group.start;\n    const groupLength = groupStart + group.count;\n    for (let j = groupStart; j < groupLength; j++) {\n      newIndices.push(index.getX(j));\n    }\n  }\n  geometry.dispose(); // Required to force buffer recreation\n  geometry.setIndex(newIndices);\n\n  // update groups indices\n\n  let start = 0;\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    group.start = start;\n    start += group.count;\n  }\n\n  // merge groups\n\n  let currentGroup = groups[0];\n  geometry.groups = [currentGroup];\n  for (let i = 1; i < groups.length; i++) {\n    const group = groups[i];\n    if (currentGroup.materialIndex === group.materialIndex) {\n      currentGroup.count += group.count;\n    } else {\n      currentGroup = group;\n      geometry.groups.push(currentGroup);\n    }\n  }\n  return geometry;\n}\nexport { computeTangents, mergeBufferGeometries, mergeBufferAttributes, interleaveAttributes, estimateBytesUsed, mergeVertices, toTrianglesDrawMode, computeMorphedAttributes, mergeGroups };","map":{"version":3,"names":["BufferAttribute","BufferGeometry","Float32BufferAttribute","InterleavedBuffer","InterleavedBufferAttribute","MathUtils","TriangleFanDrawMode","TriangleStripDrawMode","TrianglesDrawMode","Vector3","computeTangents","geometry","MikkTSpace","negateSign","isReady","Error","getAttributeArray","attribute","normalized","isInterleavedBufferAttribute","srcArray","data","array","dstArray","Float32Array","getCount","itemSize","i","j","denormalize","getX","getY","getZ","_geometry","index","toNonIndexed","tangents","generateTangents","attributes","position","normal","uv","length","setAttribute","copy","mergeBufferGeometries","geometries","useGroups","isIndexed","attributesUsed","Set","Object","keys","morphAttributesUsed","morphAttributes","morphTargetsRelative","mergedGeometry","offset","attributesCount","console","error","name","has","undefined","push","size","userData","mergedUserData","count","addGroup","indexOffset","mergedIndex","setIndex","mergedAttribute","mergeBufferAttributes","numMorphTargets","morphAttributesToMerge","mergedMorphAttribute","TypedArray","arrayLength","constructor","set","interleaveAttributes","stride","l","interleavedBuffer","res","getters","setters","iba","c","k","estimateBytesUsed","mem","attr","getAttribute","BYTES_PER_ELEMENT","indices","getIndex","mergeVertices","tolerance","Math","max","Number","EPSILON","hashToIndex","positions","vertexCount","nextIndex","attributeNames","attrArrays","morphAttrsArrays","newIndices","morphAttr","Array","fill","map","decimalShift","log10","shiftMultiplier","pow","hash","newarray","newMorphArrays","getterFunc","m","ml","result","clone","oldAttribute","buffer","oldMorphAttribute","morphAttribute","toTrianglesDrawMode","drawMode","warn","numberOfTriangles","newGeometry","clearGroups","computeMorphedAttributes","object","isBufferGeometry","_vA","_vB","_vC","_tempA","_tempB","_tempC","_morphA","_morphB","_morphC","_calculateMorphedAttributeData","material","a","b","modifiedAttributeArray","fromBufferAttribute","morphInfluences","morphTargetInfluences","morphTargets","il","influence","morph","addScaledVector","sub","add","isSkinnedMesh","boneTransform","x","y","z","positionAttribute","morphPosition","normalAttribute","morphNormal","groups","drawRange","jl","group","groupMaterial","start","end","modifiedPosition","modifiedNormal","isArray","materialIndex","min","morphedPositionAttribute","morphedNormalAttribute","mergeGroups","sort","groupStart","groupLength","dispose","currentGroup"],"sources":["/Users/avi/Desktop/mywebsite/node_modules/three/examples/jsm/utils/BufferGeometryUtils.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tMathUtils,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3,\n} from 'three';\n\n\nfunction computeTangents( geometry, MikkTSpace, negateSign = true ) {\n\n\tif ( ! MikkTSpace || ! MikkTSpace.isReady ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' );\n\n\t}\n\n\tfunction getAttributeArray( attribute ) {\n\n\t\tif ( attribute.normalized || attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst srcArray = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;\n\t\t\tconst dstArray = new Float32Array( attribute.getCount() * attribute.itemSize );\n\n\t\t\tfor ( let i = 0, j = 0; i < attribute.getCount(); i ++ ) {\n\n\t\t\t\tdstArray[ j ++ ] = MathUtils.denormalize( attribute.getX( i ), srcArray );\n\t\t\t\tdstArray[ j ++ ] = MathUtils.denormalize( attribute.getY( i ), srcArray );\n\n\t\t\t\tif ( attribute.itemSize > 2 ) {\n\n\t\t\t\t\tdstArray[ j ++ ] = MathUtils.denormalize( attribute.getZ( i ), srcArray );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t\tif ( attribute.array instanceof Float32Array ) {\n\n\t\t\treturn attribute.array;\n\n\t\t}\n\n\t\treturn new Float32Array( attribute.array );\n\n\t}\n\n\t// MikkTSpace algorithm requires non-indexed input.\n\n\tconst _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\n\t// Compute vertex tangents.\n\n\tconst tangents = MikkTSpace.generateTangents(\n\n\t\tgetAttributeArray( _geometry.attributes.position ),\n\t\tgetAttributeArray( _geometry.attributes.normal ),\n\t\tgetAttributeArray( _geometry.attributes.uv )\n\n\t);\n\n\t// Texture coordinate convention of glTF differs from the apparent\n\t// default of the MikkTSpace library; .w component must be flipped.\n\n\tif ( negateSign ) {\n\n\t\tfor ( let i = 3; i < tangents.length; i += 4 ) {\n\n\t\t\ttangents[ i ] *= - 1;\n\n\t\t}\n\n\t}\n\n\t//\n\n\t_geometry.setAttribute( 'tangent', new BufferAttribute( tangents, 4 ) );\n\n\tif ( geometry !== _geometry ) {\n\n\t\tgeometry.copy( _geometry )\n\n\t}\n\n\treturn geometry;\n\n}\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nfunction mergeBufferGeometries( geometries, useGroups = false ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\tconst attributes = {};\n\tconst morphAttributes = {};\n\n\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\tconst mergedGeometry = new BufferGeometry();\n\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather morph attributes, exit early if they're different\n\n\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t}\n\n\t\t// gather .userData\n\n\t\tmergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n\t\tmergedGeometry.userData.mergedUserData.push( geometry.userData );\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\n\tif ( isIndexed ) {\n\n\t\tlet indexOffset = 0;\n\t\tconst mergedIndex = [];\n\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst index = geometries[ i ].index;\n\n\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t}\n\n\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t}\n\n\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t}\n\n\t// merge attributes\n\n\tfor ( const name in attributes ) {\n\n\t\tconst mergedAttribute = mergeBufferAttributes( attributes[ name ] );\n\n\t\tif ( ! mergedAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t}\n\n\t// merge morph attributes\n\n\tfor ( const name in morphAttributes ) {\n\n\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\tif ( numMorphTargets === 0 ) break;\n\n\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\tconst morphAttributesToMerge = [];\n\n\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t}\n\n\t\t\tconst mergedMorphAttribute = mergeBufferAttributes( morphAttributesToMerge );\n\n\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t}\n\n\t}\n\n\treturn mergedGeometry;\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nfunction mergeBufferAttributes( attributes ) {\n\n\tlet TypedArray;\n\tlet itemSize;\n\tlet normalized;\n\tlet arrayLength = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\n\t}\n\n\tconst array = new TypedArray( arrayLength );\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tarray.set( attributes[ i ].array, offset );\n\n\t\toffset += attributes[ i ].array.length;\n\n\t}\n\n\treturn new BufferAttribute( array, itemSize, normalized );\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nfunction interleaveAttributes( attributes ) {\n\n\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t// a set of InterleavedBufferAttributes for each attribute\n\tlet TypedArray;\n\tlet arrayLength = 0;\n\tlet stride = 0;\n\n\t// calculate the the length and type of the interleavedBuffer\n\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\t\tstride += attribute.itemSize;\n\n\t}\n\n\t// Create the set of buffer attributes\n\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\tlet offset = 0;\n\tconst res = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\tconst attribute = attributes[ j ];\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst count = attribute.count;\n\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\tres.push( iba );\n\n\t\toffset += itemSize;\n\n\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t// at the appropriate offset\n\t\tfor ( let c = 0; c < count; c ++ ) {\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\nfunction estimateBytesUsed( geometry ) {\n\n\t// Return the estimated memory used by this geometry in bytes\n\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t// for InterleavedBufferAttributes.\n\tlet mem = 0;\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst attr = geometry.getAttribute( name );\n\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t}\n\n\tconst indices = geometry.getIndex();\n\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\treturn mem;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry>}\n */\nfunction mergeVertices( geometry, tolerance = 1e-4 ) {\n\n\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t// if it's already available.\n\tconst hashToIndex = {};\n\tconst indices = geometry.getIndex();\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t// next value for triangle indices\n\tlet nextIndex = 0;\n\n\t// attributes and new attribute arrays\n\tconst attributeNames = Object.keys( geometry.attributes );\n\tconst attrArrays = {};\n\tconst morphAttrsArrays = {};\n\tconst newIndices = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\n\t// initialize the arrays\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\n\t\tattrArrays[ name ] = [];\n\n\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\tif ( morphAttr ) {\n\n\t\t\tmorphAttrsArrays[ name ] = new Array( morphAttr.length ).fill().map( () => [] );\n\n\t\t}\n\n\t}\n\n\t// convert the error tolerance to an amount of decimal places to truncate to\n\tconst decimalShift = Math.log10( 1 / tolerance );\n\tconst shiftMultiplier = Math.pow( 10, decimalShift );\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\tlet hash = '';\n\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\tconst name = attributeNames[ j ];\n\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * shiftMultiplier ) },`;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add another reference to the vertex if it's already\n\t\t// used by another index\n\t\tif ( hash in hashToIndex ) {\n\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t} else {\n\n\t\t\t// copy data to the new index in the attribute arrays\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tconst name = attributeNames[ j ];\n\t\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst newarray = attrArrays[ name ];\n\t\t\t\tconst newMorphArrays = morphAttrsArrays[ name ];\n\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tconst getterFunc = getters[ k ];\n\t\t\t\t\tnewarray.push( attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\tif ( morphAttr ) {\n\n\t\t\t\t\t\tfor ( let m = 0, ml = morphAttr.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\tnewMorphArrays[ m ].push( morphAttr[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\tnewIndices.push( nextIndex );\n\t\t\tnextIndex ++;\n\n\t\t}\n\n\t}\n\n\t// Generate typed arrays from new attribute arrays and update\n\t// the attributeBuffers\n\tconst result = geometry.clone();\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\t\tconst oldAttribute = geometry.getAttribute( name );\n\n\t\tconst buffer = new oldAttribute.array.constructor( attrArrays[ name ] );\n\t\tconst attribute = new BufferAttribute( buffer, oldAttribute.itemSize, oldAttribute.normalized );\n\n\t\tresult.setAttribute( name, attribute );\n\n\t\t// Update the attribute arrays\n\t\tif ( name in morphAttrsArrays ) {\n\n\t\t\tfor ( let j = 0; j < morphAttrsArrays[ name ].length; j ++ ) {\n\n\t\t\t\tconst oldMorphAttribute = geometry.morphAttributes[ name ][ j ];\n\n\t\t\t\tconst buffer = new oldMorphAttribute.array.constructor( morphAttrsArrays[ name ][ j ] );\n\t\t\t\tconst morphAttribute = new BufferAttribute( buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized );\n\t\t\t\tresult.morphAttributes[ name ][ j ] = morphAttribute;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tresult.setIndex( newIndices );\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry>}\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\treturn geometry;\n\n\t}\n\n\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\tlet index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst numberOfTriangles = index.count - 2;\n\t\tconst newIndices = [];\n\n\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tconst newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\t\tnewGeometry.clearGroups();\n\n\t\treturn newGeometry;\n\n\t} else {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\treturn geometry;\n\n\t}\n\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes( object ) {\n\n\tif ( object.geometry.isBufferGeometry !== true ) {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.' );\n\t\treturn null;\n\n\t}\n\n\tconst _vA = new Vector3();\n\tconst _vB = new Vector3();\n\tconst _vC = new Vector3();\n\n\tconst _tempA = new Vector3();\n\tconst _tempB = new Vector3();\n\tconst _tempC = new Vector3();\n\n\tconst _morphA = new Vector3();\n\tconst _morphB = new Vector3();\n\tconst _morphC = new Vector3();\n\n\tfunction _calculateMorphedAttributeData(\n\t\tobject,\n\t\tmaterial,\n\t\tattribute,\n\t\tmorphAttribute,\n\t\tmorphTargetsRelative,\n\t\ta,\n\t\tb,\n\t\tc,\n\t\tmodifiedAttributeArray\n\t) {\n\n\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif ( material.morphTargets && morphAttribute && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morph = morphAttribute[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morph, a );\n\t\t\t\t_tempB.fromBufferAttribute( morph, b );\n\t\t\t\t_tempC.fromBufferAttribute( morph, c );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_vA.add( _morphA );\n\t\t\t_vB.add( _morphB );\n\t\t\t_vC.add( _morphC );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tobject.boneTransform( a, _vA );\n\t\t\tobject.boneTransform( b, _vB );\n\t\t\tobject.boneTransform( c, _vC );\n\n\t\t}\n\n\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t}\n\n\tconst geometry = object.geometry;\n\tconst material = object.material;\n\n\tlet a, b, c;\n\tconst index = geometry.index;\n\tconst positionAttribute = geometry.attributes.position;\n\tconst morphPosition = geometry.morphAttributes.position;\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\tconst normalAttribute = geometry.attributes.normal;\n\tconst morphNormal = geometry.morphAttributes.position;\n\n\tconst groups = geometry.groups;\n\tconst drawRange = geometry.drawRange;\n\tlet i, j, il, jl;\n\tlet group, groupMaterial;\n\tlet start, end;\n\n\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\tif ( index !== null ) {\n\n\t\t// indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\t\t\t\tgroupMaterial = material[ group.materialIndex ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = index.getX( i );\n\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tmaterial,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tmaterial,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// non-indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\t\t\t\tgroupMaterial = material[ group.materialIndex ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = j;\n\t\t\t\t\tb = j + 1;\n\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = i;\n\t\t\t\tb = i + 1;\n\t\t\t\tc = i + 2;\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tmaterial,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tmaterial,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\treturn {\n\n\t\tpositionAttribute: positionAttribute,\n\t\tnormalAttribute: normalAttribute,\n\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t};\n\n}\n\nfunction mergeGroups( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.' );\n\t\treturn geometry;\n\n\t}\n\n\tlet groups = geometry.groups;\n\n\t// sort groups by material index\n\n\tgroups = groups.sort( ( a, b ) => {\n\n\t\tif ( a.materialIndex !== b.materialIndex ) return a.materialIndex - b.materialIndex;\n\n\t\treturn a.start - b.start;\n\n\t} );\n\n\t// create index for non-indexed geometries\n\n\tif ( geometry.getIndex() === null ) {\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\t\tconst indices = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\tindices.push( i, i + 1, i + 2 );\n\n\t\t}\n\n\t\tgeometry.setIndex( indices );\n\n\t}\n\n\t// sort index\n\n\tconst index = geometry.getIndex();\n\n\tconst newIndices = [];\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tconst groupStart = group.start;\n\t\tconst groupLength = groupStart + group.count;\n\n\t\tfor ( let j = groupStart; j < groupLength; j ++ ) {\n\n\t\t\tnewIndices.push( index.getX( j ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dispose(); // Required to force buffer recreation\n\tgeometry.setIndex( newIndices );\n\n\t// update groups indices\n\n\tlet start = 0;\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tgroup.start = start;\n\t\tstart += group.count;\n\n\t}\n\n\t// merge groups\n\n\tlet currentGroup = groups[ 0 ];\n\n\tgeometry.groups = [ currentGroup ];\n\n\tfor ( let i = 1; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tif ( currentGroup.materialIndex === group.materialIndex ) {\n\n\t\t\tcurrentGroup.count += group.count;\n\n\t\t} else {\n\n\t\t\tcurrentGroup = group;\n\t\t\tgeometry.groups.push( currentGroup );\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n}\n\nexport {\n\tcomputeTangents,\n\tmergeBufferGeometries,\n\tmergeBufferAttributes,\n\tinterleaveAttributes,\n\testimateBytesUsed,\n\tmergeVertices,\n\ttoTrianglesDrawMode,\n\tcomputeMorphedAttributes,\n\tmergeGroups\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}